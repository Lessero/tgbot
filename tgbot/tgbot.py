import os
import logging
import requests
import random
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters,
)
from openai import OpenAI

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env —Ñ–∞–π–ª–∞
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
DEEPSEEK_API_KEY = os.getenv("DEEPSEEK_API_KEY")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ DeepSeek
client = OpenAI(
    api_key=DEEPSEEK_API_KEY,
    base_url="https://api.deepseek.com"
)

# –ì–ª–∞–≤–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏
def main_keyboard():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("–°–∫–∏–Ω—å –∫–æ—Ç–∞", callback_data="get_cat"),
            InlineKeyboardButton("–°–∫–∏–Ω—å —Ü–∏—Ç–∞—Ç—É", callback_data="get_quote")
        ],
        [
            InlineKeyboardButton("–û—Ç–≤–µ—Ç—å –º–Ω–µ –∫–∞–∫...", callback_data="reply_as_character")
        ]
    ])

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! –ù–∞–∂–º–∏ –æ–¥–Ω—É –∏–∑ –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ:",
        reply_markup=main_keyboard()
    )

# –ö–æ–º–∞–Ω–¥–∞ /help
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–Ø –±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç:\n"
        "- –ü–æ–∫–∞–∑–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–æ—Ç–∞\n"
        "- –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ü–∏—Ç–∞—Ç—É\n"
        "- –û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å –≤ —Å—Ç–∏–ª–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞\n\n"
        "–ü—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É!"
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    logger.info(f"–ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞: {query.data}")

    if query.data == "get_cat":
        try:
            response = requests.get("https://api.thecatapi.com/v1/images/search")
            data = response.json()
            cat_image_url = data[0]["url"]
            await context.bot.send_photo(
                chat_id=update.effective_chat.id,
                photo=cat_image_url,
                caption="–í–æ—Ç —Ç–µ–±–µ –∫–æ—Ç–∏–∫! üê±",
                reply_markup=main_keyboard()
            )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–æ—Ç–∞: {e}")
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–æ—Ç–∞.",
                reply_markup=main_keyboard()
            )

    elif query.data == "get_quote":
        try:
            response = requests.get("https://api.forismatic.com/api/1.0/?method=getQuote&format=json&lang=ru")
            data = response.json()
            quote = data.get("quoteText", "–¶–∏—Ç–∞—Ç–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
            author = data.get("quoteAuthor", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–≤—Ç–æ—Ä")
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"\"{quote}\"\n\n¬© {author}",
                reply_markup=main_keyboard()
            )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–∏—Ç–∞—Ç—ã: {e}")
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–∏—Ç–∞—Ç—É.",
                reply_markup=main_keyboard()
            )

    elif query.data == "reply_as_character":
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞, –≤ —Å—Ç–∏–ª–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç:",
        )
        context.user_data['awaiting_character'] = True

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get('awaiting_character'):
        context.user_data['character_name'] = update.message.text
        context.user_data['awaiting_character'] = False
        context.user_data['awaiting_question'] = True
        await update.message.reply_text(f"–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –¥–ª—è {update.message.text}:")
    elif context.user_data.get('awaiting_question'):
        character_name = context.user_data.get('character_name')
        question = update.message.text
        context.user_data['awaiting_question'] = False

        prompt = f"–ü—Ä–µ–¥—Å—Ç–∞–≤—å, —á—Ç–æ —Ç—ã {character_name}. –û—Ç–≤–µ—Ç—å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å –≤ –µ–≥–æ —Å—Ç–∏–ª–µ: {question}"

        response = await get_deepseek_response(prompt)

        await update.message.reply_text(response, reply_markup=main_keyboard())
    else:
        try:
            base_path = os.path.dirname(os.path.abspath(__file__))
            filepath = os.path.join(base_path, "warn_replies.txt")
            with open(filepath, "r", encoding="utf-8") as f:
                lines = [line.strip() for line in f if line.strip()]
            reply = random.choice(lines)
        except Exception as e:
            reply = "–ö–Ω–æ–ø–∫–∏ —Ç—ã–∫–∞–π, —Å—é–¥–∞ –Ω–µ –ø–∏—à–∏! (–æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ—Ä–∞–∑)"
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ—Ä–∞–∑: {e}")

        await update.message.reply_text(reply, reply_markup=main_keyboard())

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –∫ DeepSeek
async def get_deepseek_response(prompt):
    try:
        response = client.chat.completions.create(
            model="deepseek-chat",
            messages=[
                {"role": "system", "content": "–í—ã ‚Äî –ø–æ–ª–µ–∑–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=1000
        )
        return response.choices[0].message.content
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ DeepSeek: {e}")
        return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞ –æ—Ç AI."

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
def main():
    if not TELEGRAM_BOT_TOKEN or not DEEPSEEK_API_KEY:
        logger.error("–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å TELEGRAM_BOT_TOKEN –∏ DEEPSEEK_API_KEY –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")
        return

    app = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CallbackQueryHandler(button, pattern=".*"))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    app.run_polling()

if __name__ == "__main__":
    main()
